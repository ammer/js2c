#! /usr/bin/env node

var program = require('commander'),
    fs = require('fs'),
    _ = require('underscore'),
    esprima = require('esprima'),
    rocambole = require('rocambole');

var js2c = require('./lib/transformer.js'),
    utils = require('./lib/utils.js');

program
    .version(require('./package.json').version)
    .alias('t')
    .usage('<infile> [outfile]')
    .option('-i, --include <path>', 'function definition json file')
    .option('-e, --entry <name>', 'entry function name, default: "entry"')
    .parse(process.argv);

if (program.args.length !== 1 && program.args.length !== 2) {
    console.error('js2c exec should be called with an input and output file, or one arguments if output to stdout');
    process.exit(1);
}

// include
// if (_.isString(program.include)) {
//     var funcDefs = include(program.include);
// } else {
//     var funcDefs = {};
// }
var funcDefs = include(program.include);

// entry
var entry = program.entry;
if(entry === undefined) {
    entry = "entry";
}

// input file
var infile = program.args[0];
// try {
//     var content = utils.readFile(infile);
// } catch(e) {
//     console.error('Error opening: ' + infile);
//     process.exit(1);
// }
// var ast = rocambole.parse(content);
var ast = utils.astFromJsFile(infile);

// type inference
var inferPass = require('./lib/inferpass.js')();
var newAst = inferPass.run(ast, funcDefs);

// codegen
var transformer = new js2c.Transformer(newAst, entry, funcDefs);
var cSource = transformer.transfer();

// output
if (program.args.length === 2) {
    var outfile = program.args[1];

    try {
	fs.writeFileSync(outfile, cSource);
    } catch (e) {
	console.error('Error writing to: ' + outfile);
	process.exit(1);
    }
} else {
    console.info(JSON.stringify(cSource));
}
